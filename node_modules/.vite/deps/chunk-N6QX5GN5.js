import {
  __commonJS
} from "./chunk-76J2PTFD.js";

// ../../../../../../node_modules/seed-random/index.js
var require_seed_random = __commonJS({
  "../../../../../../node_modules/seed-random/index.js"(exports, module) {
    "use strict";
    var width = 256;
    var chunks = 6;
    var digits = 52;
    var pool = [];
    var GLOBAL = typeof global === "undefined" ? window : global;
    var startdenom = Math.pow(width, chunks);
    var significance = Math.pow(2, digits);
    var overflow = significance * 2;
    var mask = width - 1;
    var oldRandom = Math.random;
    module.exports = function(seed, options) {
      if (options && options.global === true) {
        options.global = false;
        Math.random = module.exports(seed, options);
        options.global = true;
        return Math.random;
      }
      var use_entropy = options && options.entropy || false;
      var key = [];
      var shortseed = mixkey(flatten(
        use_entropy ? [seed, tostring(pool)] : 0 in arguments ? seed : autoseed(),
        3
      ), key);
      var arc4 = new ARC4(key);
      mixkey(tostring(arc4.S), pool);
      return function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
    };
    module.exports.resetGlobal = function() {
      Math.random = oldRandom;
    };
    function ARC4(key) {
      var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
        s[j] = t;
      }
      (me.g = function(count) {
        var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
        while (count--) {
          t2 = s2[i2 = mask & i2 + 1];
          r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
        }
        me.i = i2;
        me.j = j2;
        return r;
      })(width);
    }
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj)[0], prop;
      if (depth && typ == "o") {
        for (prop in obj) {
          try {
            result.push(flatten(obj[prop], depth - 1));
          } catch (e) {
          }
        }
      }
      return result.length ? result : typ == "s" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed(seed) {
      try {
        GLOBAL.crypto.getRandomValues(seed = new Uint8Array(width));
        return tostring(seed);
      } catch (e) {
        return [
          +/* @__PURE__ */ new Date(),
          GLOBAL,
          GLOBAL.navigator && GLOBAL.navigator.plugins,
          GLOBAL.screen,
          tostring(pool)
        ];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(Math.random(), pool);
  }
});

// ../../../../../../node_modules/simplex-noise/simplex-noise.js
var require_simplex_noise = __commonJS({
  "../../../../../../node_modules/simplex-noise/simplex-noise.js"(exports, module) {
    (function() {
      "use strict";
      var F2 = 0.5 * (Math.sqrt(3) - 1);
      var G2 = (3 - Math.sqrt(3)) / 6;
      var F3 = 1 / 3;
      var G3 = 1 / 6;
      var F4 = (Math.sqrt(5) - 1) / 4;
      var G4 = (5 - Math.sqrt(5)) / 20;
      function SimplexNoise(randomOrSeed) {
        var random;
        if (typeof randomOrSeed == "function") {
          random = randomOrSeed;
        } else if (randomOrSeed) {
          random = alea(randomOrSeed);
        } else {
          random = Math.random;
        }
        this.p = buildPermutationTable(random);
        this.perm = new Uint8Array(512);
        this.permMod12 = new Uint8Array(512);
        for (var i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255];
          this.permMod12[i] = this.perm[i] % 12;
        }
      }
      SimplexNoise.prototype = {
        grad3: new Float32Array([
          1,
          1,
          0,
          -1,
          1,
          0,
          1,
          -1,
          0,
          -1,
          -1,
          0,
          1,
          0,
          1,
          -1,
          0,
          1,
          1,
          0,
          -1,
          -1,
          0,
          -1,
          0,
          1,
          1,
          0,
          -1,
          1,
          0,
          1,
          -1,
          0,
          -1,
          -1
        ]),
        grad4: new Float32Array([
          0,
          1,
          1,
          1,
          0,
          1,
          1,
          -1,
          0,
          1,
          -1,
          1,
          0,
          1,
          -1,
          -1,
          0,
          -1,
          1,
          1,
          0,
          -1,
          1,
          -1,
          0,
          -1,
          -1,
          1,
          0,
          -1,
          -1,
          -1,
          1,
          0,
          1,
          1,
          1,
          0,
          1,
          -1,
          1,
          0,
          -1,
          1,
          1,
          0,
          -1,
          -1,
          -1,
          0,
          1,
          1,
          -1,
          0,
          1,
          -1,
          -1,
          0,
          -1,
          1,
          -1,
          0,
          -1,
          -1,
          1,
          1,
          0,
          1,
          1,
          1,
          0,
          -1,
          1,
          -1,
          0,
          1,
          1,
          -1,
          0,
          -1,
          -1,
          1,
          0,
          1,
          -1,
          1,
          0,
          -1,
          -1,
          -1,
          0,
          1,
          -1,
          -1,
          0,
          -1,
          1,
          1,
          1,
          0,
          1,
          1,
          -1,
          0,
          1,
          -1,
          1,
          0,
          1,
          -1,
          -1,
          0,
          -1,
          1,
          1,
          0,
          -1,
          1,
          -1,
          0,
          -1,
          -1,
          1,
          0,
          -1,
          -1,
          -1,
          0
        ]),
        noise2D: function(xin, yin) {
          var permMod12 = this.permMod12;
          var perm = this.perm;
          var grad3 = this.grad3;
          var n0 = 0;
          var n1 = 0;
          var n2 = 0;
          var s = (xin + yin) * F2;
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var t = (i + j) * G2;
          var X0 = i - t;
          var Y0 = j - t;
          var x0 = xin - X0;
          var y0 = yin - Y0;
          var i1, j1;
          if (x0 > y0) {
            i1 = 1;
            j1 = 0;
          } else {
            i1 = 0;
            j1 = 1;
          }
          var x1 = x0 - i1 + G2;
          var y1 = y0 - j1 + G2;
          var x2 = x0 - 1 + 2 * G2;
          var y2 = y0 - 1 + 2 * G2;
          var ii = i & 255;
          var jj = j & 255;
          var t0 = 0.5 - x0 * x0 - y0 * y0;
          if (t0 >= 0) {
            var gi0 = permMod12[ii + perm[jj]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0);
          }
          var t1 = 0.5 - x1 * x1 - y1 * y1;
          if (t1 >= 0) {
            var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);
          }
          var t2 = 0.5 - x2 * x2 - y2 * y2;
          if (t2 >= 0) {
            var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);
          }
          return 70 * (n0 + n1 + n2);
        },
        // 3D simplex noise
        noise3D: function(xin, yin, zin) {
          var permMod12 = this.permMod12;
          var perm = this.perm;
          var grad3 = this.grad3;
          var n0, n1, n2, n3;
          var s = (xin + yin + zin) * F3;
          var i = Math.floor(xin + s);
          var j = Math.floor(yin + s);
          var k = Math.floor(zin + s);
          var t = (i + j + k) * G3;
          var X0 = i - t;
          var Y0 = j - t;
          var Z0 = k - t;
          var x0 = xin - X0;
          var y0 = yin - Y0;
          var z0 = zin - Z0;
          var i1, j1, k1;
          var i2, j2, k2;
          if (x0 >= y0) {
            if (y0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            } else if (x0 >= z0) {
              i1 = 1;
              j1 = 0;
              k1 = 0;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 1;
              j2 = 0;
              k2 = 1;
            }
          } else {
            if (y0 < z0) {
              i1 = 0;
              j1 = 0;
              k1 = 1;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else if (x0 < z0) {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 0;
              j2 = 1;
              k2 = 1;
            } else {
              i1 = 0;
              j1 = 1;
              k1 = 0;
              i2 = 1;
              j2 = 1;
              k2 = 0;
            }
          }
          var x1 = x0 - i1 + G3;
          var y1 = y0 - j1 + G3;
          var z1 = z0 - k1 + G3;
          var x2 = x0 - i2 + 2 * G3;
          var y2 = y0 - j2 + 2 * G3;
          var z2 = z0 - k2 + 2 * G3;
          var x3 = x0 - 1 + 3 * G3;
          var y3 = y0 - 1 + 3 * G3;
          var z3 = z0 - 1 + 3 * G3;
          var ii = i & 255;
          var jj = j & 255;
          var kk = k & 255;
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;
          if (t0 < 0)
            n0 = 0;
          else {
            var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;
            t0 *= t0;
            n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;
          if (t1 < 0)
            n1 = 0;
          else {
            var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;
            t1 *= t1;
            n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;
          if (t2 < 0)
            n2 = 0;
          else {
            var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;
            t2 *= t2;
            n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;
          if (t3 < 0)
            n3 = 0;
          else {
            var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;
            t3 *= t3;
            n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);
          }
          return 32 * (n0 + n1 + n2 + n3);
        },
        // 4D simplex noise, better simplex rank ordering method 2012-03-09
        noise4D: function(x, y, z, w) {
          var perm = this.perm;
          var grad4 = this.grad4;
          var n0, n1, n2, n3, n4;
          var s = (x + y + z + w) * F4;
          var i = Math.floor(x + s);
          var j = Math.floor(y + s);
          var k = Math.floor(z + s);
          var l = Math.floor(w + s);
          var t = (i + j + k + l) * G4;
          var X0 = i - t;
          var Y0 = j - t;
          var Z0 = k - t;
          var W0 = l - t;
          var x0 = x - X0;
          var y0 = y - Y0;
          var z0 = z - Z0;
          var w0 = w - W0;
          var rankx = 0;
          var ranky = 0;
          var rankz = 0;
          var rankw = 0;
          if (x0 > y0)
            rankx++;
          else
            ranky++;
          if (x0 > z0)
            rankx++;
          else
            rankz++;
          if (x0 > w0)
            rankx++;
          else
            rankw++;
          if (y0 > z0)
            ranky++;
          else
            rankz++;
          if (y0 > w0)
            ranky++;
          else
            rankw++;
          if (z0 > w0)
            rankz++;
          else
            rankw++;
          var i1, j1, k1, l1;
          var i2, j2, k2, l2;
          var i3, j3, k3, l3;
          i1 = rankx >= 3 ? 1 : 0;
          j1 = ranky >= 3 ? 1 : 0;
          k1 = rankz >= 3 ? 1 : 0;
          l1 = rankw >= 3 ? 1 : 0;
          i2 = rankx >= 2 ? 1 : 0;
          j2 = ranky >= 2 ? 1 : 0;
          k2 = rankz >= 2 ? 1 : 0;
          l2 = rankw >= 2 ? 1 : 0;
          i3 = rankx >= 1 ? 1 : 0;
          j3 = ranky >= 1 ? 1 : 0;
          k3 = rankz >= 1 ? 1 : 0;
          l3 = rankw >= 1 ? 1 : 0;
          var x1 = x0 - i1 + G4;
          var y1 = y0 - j1 + G4;
          var z1 = z0 - k1 + G4;
          var w1 = w0 - l1 + G4;
          var x2 = x0 - i2 + 2 * G4;
          var y2 = y0 - j2 + 2 * G4;
          var z2 = z0 - k2 + 2 * G4;
          var w2 = w0 - l2 + 2 * G4;
          var x3 = x0 - i3 + 3 * G4;
          var y3 = y0 - j3 + 3 * G4;
          var z3 = z0 - k3 + 3 * G4;
          var w3 = w0 - l3 + 3 * G4;
          var x4 = x0 - 1 + 4 * G4;
          var y4 = y0 - 1 + 4 * G4;
          var z4 = z0 - 1 + 4 * G4;
          var w4 = w0 - 1 + 4 * G4;
          var ii = i & 255;
          var jj = j & 255;
          var kk = k & 255;
          var ll = l & 255;
          var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
          if (t0 < 0)
            n0 = 0;
          else {
            var gi0 = perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32 * 4;
            t0 *= t0;
            n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);
          }
          var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
          if (t1 < 0)
            n1 = 0;
          else {
            var gi1 = perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32 * 4;
            t1 *= t1;
            n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);
          }
          var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
          if (t2 < 0)
            n2 = 0;
          else {
            var gi2 = perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32 * 4;
            t2 *= t2;
            n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);
          }
          var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
          if (t3 < 0)
            n3 = 0;
          else {
            var gi3 = perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32 * 4;
            t3 *= t3;
            n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);
          }
          var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
          if (t4 < 0)
            n4 = 0;
          else {
            var gi4 = perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32 * 4;
            t4 *= t4;
            n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);
          }
          return 27 * (n0 + n1 + n2 + n3 + n4);
        }
      };
      function buildPermutationTable(random) {
        var i;
        var p = new Uint8Array(256);
        for (i = 0; i < 256; i++) {
          p[i] = i;
        }
        for (i = 0; i < 255; i++) {
          var r = i + ~~(random() * (256 - i));
          var aux = p[i];
          p[i] = p[r];
          p[r] = aux;
        }
        return p;
      }
      SimplexNoise._buildPermutationTable = buildPermutationTable;
      function alea() {
        var s0 = 0;
        var s1 = 0;
        var s2 = 0;
        var c = 1;
        var mash = masher();
        s0 = mash(" ");
        s1 = mash(" ");
        s2 = mash(" ");
        for (var i = 0; i < arguments.length; i++) {
          s0 -= mash(arguments[i]);
          if (s0 < 0) {
            s0 += 1;
          }
          s1 -= mash(arguments[i]);
          if (s1 < 0) {
            s1 += 1;
          }
          s2 -= mash(arguments[i]);
          if (s2 < 0) {
            s2 += 1;
          }
        }
        mash = null;
        return function() {
          var t = 2091639 * s0 + c * 23283064365386963e-26;
          s0 = s1;
          s1 = s2;
          return s2 = t - (c = t | 0);
        };
      }
      function masher() {
        var n = 4022871197;
        return function(data) {
          data = data.toString();
          for (var i = 0; i < data.length; i++) {
            n += data.charCodeAt(i);
            var h = 0.02519603282416938 * n;
            n = h >>> 0;
            h -= n;
            h *= n;
            n = h >>> 0;
            h -= n;
            n += h * 4294967296;
          }
          return (n >>> 0) * 23283064365386963e-26;
        };
      }
      if (typeof define !== "undefined" && define.amd)
        define(function() {
          return SimplexNoise;
        });
      if (typeof exports !== "undefined")
        exports.SimplexNoise = SimplexNoise;
      else if (typeof window !== "undefined")
        window.SimplexNoise = SimplexNoise;
      if (typeof module !== "undefined") {
        module.exports = SimplexNoise;
      }
    })();
  }
});

// ../../../../../../node_modules/defined/index.js
var require_defined = __commonJS({
  "../../../../../../node_modules/defined/index.js"(exports, module) {
    "use strict";
    module.exports = function defined() {
      for (var i = 0; i < arguments.length; i++) {
        if (typeof arguments[i] !== "undefined") {
          return arguments[i];
        }
      }
    };
  }
});

// ../../../../../../node_modules/canvas-sketch-util/random.js
var require_random = __commonJS({
  "../../../../../../node_modules/canvas-sketch-util/random.js"(exports, module) {
    var seedRandom = require_seed_random();
    var SimplexNoise = require_simplex_noise();
    var defined = require_defined();
    function createRandom(defaultSeed) {
      defaultSeed = defined(defaultSeed, null);
      var defaultRandom = Math.random;
      var currentSeed;
      var currentRandom;
      var noiseGenerator;
      var _nextGaussian = null;
      var _hasNextGaussian = false;
      setSeed(defaultSeed);
      return {
        value,
        createRandom: function(defaultSeed2) {
          return createRandom(defaultSeed2);
        },
        setSeed,
        getSeed,
        getRandomSeed,
        valueNonZero,
        permuteNoise,
        noise1D,
        noise2D,
        noise3D,
        noise4D,
        sign,
        boolean,
        chance,
        range,
        rangeFloor,
        pick,
        shuffle,
        onCircle,
        insideCircle,
        onSphere,
        insideSphere,
        quaternion,
        weighted,
        weightedSet,
        weightedSetIndex,
        gaussian
      };
      function setSeed(seed, opt) {
        if (typeof seed === "number" || typeof seed === "string") {
          currentSeed = seed;
          currentRandom = seedRandom(currentSeed, opt);
        } else {
          currentSeed = void 0;
          currentRandom = defaultRandom;
        }
        noiseGenerator = createNoise();
        _nextGaussian = null;
        _hasNextGaussian = false;
      }
      function value() {
        return currentRandom();
      }
      function valueNonZero() {
        var u = 0;
        while (u === 0)
          u = value();
        return u;
      }
      function getSeed() {
        return currentSeed;
      }
      function getRandomSeed() {
        var seed = String(Math.floor(Math.random() * 1e6));
        return seed;
      }
      function createNoise() {
        return new SimplexNoise(currentRandom);
      }
      function permuteNoise() {
        noiseGenerator = createNoise();
      }
      function noise1D(x, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise2D(x * frequency, 0);
      }
      function noise2D(x, y, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        if (!isFinite(y))
          throw new TypeError("y component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise2D(x * frequency, y * frequency);
      }
      function noise3D(x, y, z, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        if (!isFinite(y))
          throw new TypeError("y component for noise() must be finite");
        if (!isFinite(z))
          throw new TypeError("z component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise3D(
          x * frequency,
          y * frequency,
          z * frequency
        );
      }
      function noise4D(x, y, z, w, frequency, amplitude) {
        if (!isFinite(x))
          throw new TypeError("x component for noise() must be finite");
        if (!isFinite(y))
          throw new TypeError("y component for noise() must be finite");
        if (!isFinite(z))
          throw new TypeError("z component for noise() must be finite");
        if (!isFinite(w))
          throw new TypeError("w component for noise() must be finite");
        frequency = defined(frequency, 1);
        amplitude = defined(amplitude, 1);
        return amplitude * noiseGenerator.noise4D(
          x * frequency,
          y * frequency,
          z * frequency,
          w * frequency
        );
      }
      function sign() {
        return boolean() ? 1 : -1;
      }
      function boolean() {
        return value() > 0.5;
      }
      function chance(n) {
        n = defined(n, 0.5);
        if (typeof n !== "number")
          throw new TypeError("expected n to be a number");
        return value() < n;
      }
      function range(min, max) {
        if (max === void 0) {
          max = min;
          min = 0;
        }
        if (typeof min !== "number" || typeof max !== "number") {
          throw new TypeError("Expected all arguments to be numbers");
        }
        return value() * (max - min) + min;
      }
      function rangeFloor(min, max) {
        if (max === void 0) {
          max = min;
          min = 0;
        }
        if (typeof min !== "number" || typeof max !== "number") {
          throw new TypeError("Expected all arguments to be numbers");
        }
        return Math.floor(range(min, max));
      }
      function pick(array) {
        if (array.length === 0)
          return void 0;
        return array[rangeFloor(0, array.length)];
      }
      function shuffle(arr) {
        if (!Array.isArray(arr)) {
          throw new TypeError("Expected Array, got " + typeof arr);
        }
        var rand;
        var tmp;
        var len = arr.length;
        var ret = arr.slice();
        while (len) {
          rand = Math.floor(value() * len--);
          tmp = ret[len];
          ret[len] = ret[rand];
          ret[rand] = tmp;
        }
        return ret;
      }
      function onCircle(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        var theta = value() * 2 * Math.PI;
        out[0] = radius * Math.cos(theta);
        out[1] = radius * Math.sin(theta);
        return out;
      }
      function insideCircle(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        onCircle(1, out);
        var r = radius * Math.sqrt(value());
        out[0] *= r;
        out[1] *= r;
        return out;
      }
      function onSphere(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        var u = value() * Math.PI * 2;
        var v = value() * 2 - 1;
        var phi = u;
        var theta = Math.acos(v);
        out[0] = radius * Math.sin(theta) * Math.cos(phi);
        out[1] = radius * Math.sin(theta) * Math.sin(phi);
        out[2] = radius * Math.cos(theta);
        return out;
      }
      function insideSphere(radius, out) {
        radius = defined(radius, 1);
        out = out || [];
        var u = value() * Math.PI * 2;
        var v = value() * 2 - 1;
        var k = value();
        var phi = u;
        var theta = Math.acos(v);
        var r = radius * Math.cbrt(k);
        out[0] = r * Math.sin(theta) * Math.cos(phi);
        out[1] = r * Math.sin(theta) * Math.sin(phi);
        out[2] = r * Math.cos(theta);
        return out;
      }
      function quaternion(out) {
        out = out || [];
        var u1 = value();
        var u2 = value();
        var u3 = value();
        var sq1 = Math.sqrt(1 - u1);
        var sq2 = Math.sqrt(u1);
        var theta1 = Math.PI * 2 * u2;
        var theta2 = Math.PI * 2 * u3;
        var x = Math.sin(theta1) * sq1;
        var y = Math.cos(theta1) * sq1;
        var z = Math.sin(theta2) * sq2;
        var w = Math.cos(theta2) * sq2;
        out[0] = x;
        out[1] = y;
        out[2] = z;
        out[3] = w;
        return out;
      }
      function weightedSet(set) {
        set = set || [];
        if (set.length === 0)
          return null;
        return set[weightedSetIndex(set)].value;
      }
      function weightedSetIndex(set) {
        set = set || [];
        if (set.length === 0)
          return -1;
        return weighted(set.map(function(s) {
          return s.weight;
        }));
      }
      function weighted(weights) {
        weights = weights || [];
        if (weights.length === 0)
          return -1;
        var totalWeight = 0;
        var i;
        for (i = 0; i < weights.length; i++) {
          totalWeight += weights[i];
        }
        if (totalWeight <= 0)
          throw new Error("Weights must sum to > 0");
        var random = value() * totalWeight;
        for (i = 0; i < weights.length; i++) {
          if (random < weights[i]) {
            return i;
          }
          random -= weights[i];
        }
        return 0;
      }
      function gaussian(mean, standardDerivation) {
        mean = defined(mean, 0);
        standardDerivation = defined(standardDerivation, 1);
        if (_hasNextGaussian) {
          _hasNextGaussian = false;
          var result = _nextGaussian;
          _nextGaussian = null;
          return mean + standardDerivation * result;
        } else {
          var v1 = 0;
          var v2 = 0;
          var s = 0;
          do {
            v1 = value() * 2 - 1;
            v2 = value() * 2 - 1;
            s = v1 * v1 + v2 * v2;
          } while (s >= 1 || s === 0);
          var multiplier = Math.sqrt(-2 * Math.log(s) / s);
          _nextGaussian = v2 * multiplier;
          _hasNextGaussian = true;
          return mean + standardDerivation * (v1 * multiplier);
        }
      }
    }
    module.exports = createRandom();
  }
});

export {
  require_random
};
//# sourceMappingURL=chunk-N6QX5GN5.js.map
